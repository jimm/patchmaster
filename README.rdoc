= PatchMaster

PatchMaster is realtime MIDI performance software that alloweds a musician
to totally reconfigure a MIDI setup instantaneously and modify the MIDI data
while it's being sent.

With PatchMaster a performer can split controlling keyboards, layer MIDI
channels, transpose them, send program changes and System Exclusive
messages, limit controller and velocity values, and much more. At the stomp
of a footswitch (or any other MIDI event), an entire MIDI system can be
totally reconfigured.

PatchMaster lets you describe _songs_, which are lists of _patches_ that
connect _instruments_. Those _connections_ can send program changes, set
keyboard splits, transpose, send volume or other controller changes, and let
you apply any Ruby code you want to the MIDI stream in realtime.

_Song_ _lists_ let you organize songs into set lists for live performance or
in the studio.

Any MIDI message can _trigger_ an action such as moving to the next or
previous patch or song. For example, you can tell PatchMaster to move
forward or backward based on controller values coming from foot switches or
an instrument's buttons.

A software panic button turns off any stuck notes.

PatchMaster is cross-platform: it should run on MacOS X, Linux, JRuby, and
Windows.

PatchMaster is by Jim Menard (mailto:jim@jimmenard.com). It is a rewrite of
KeyMaster[http://jimmenard.com/projects/keymaster/].

= Requirements

* {UniMIDI}[https://github.com/arirusso/unimidi] gem.
* Ruby 1.9 (because UniMIDI requires it).
* Curses (comes with Ruby, but I'm not sure about JRuby)

= Installation

To install as a gem, type

  gem install patchmaster

= Running PatchMaster

  patchmaster [-n] [-d] [patchmaster_file]

Starts PatchMaster and optionally loads +patchmaster_file+.

The +-n+ flag tells PatchMaster to not use MIDI. All MIDI errors such as not
being able to connect to the MIDI instruments specified in pm_file are
ignored, and no MIDI data is sent/received. That is useful if you want to
run PatchMaster without actually talking to any MIDI instruments.

The +-d+ flag turns on debug mode. The app becomes slightly more verbose and
logs everything to +/tmp/pm_debug.txt+.

See "DSL" below for a description of the PatchMaster file format.

= Patches

Patches have connections and arrays of start and stop bytes. Each connection
links an input instrument to a single chanel on an output instrument.

When a patch is started (it becomes the _current_ _patch_), each connection
is started and passed the patch's start bytes to send to its output
instrument. When a patch is stopped, each connection is stopped and passed
the stop bytes to send to its output.

== Connections

Connections have an input instrument and (optional) channel, output
instrument and channel, and the following optional settings:

* Program change number (sent on the output instrument's channel)
* Keyboard zone (low/high keys stored as a Ruby Range)
* Transpose
* Filter (see "Connection Filters" below)

If the input instrument's channel is not specified then all input from that
instrument is run through the connection. If the channel is specified then
any data on other channels is ignored.

=== Start

When a connection is started:

* The start bytes from the patch, if any, are sent to the output instrument
  as-is (in particular, status bytes' channels are not changed)

* The program change is sent

* The connection adds itslef to its input instrument's list of outgoing
  connections

=== Running

When MIDI data comes in from an instrument two things happen:

* The data is sent to the instrument's triggers. Each trigger looks at the
  data and decides if it should act by send its message (for example
  +next_patch+ or +next_song+) to PM::PatchMaster.

* The data is then sent to the connections connected to the instrument, if
  any. A patch's connections are connected to an input instrument when the
  patch starts (becomes the active patch) and are disconnected when the
  patch stops.

While a patch is running (it is the current patch), each connection is given
the incoming bytes to process. A connection can filter and modify the data
on the way:

* The data is ignored if it is not on the input instrument's selected
  channel

* Note messages (note on, note off, and polyphonic pressure) are transposed

* Channel messages (note on, note off, polyphonic pressure, controller,
  program change, channel pressure, and pitch bend) have their channel
  changed to the output instrument's selected channel

* If the connection has a filter, its block of code is run and the result of
  that block becomes the bytes to be output. The filter may return an empty
  array or nil which will prevent anything from being sent to the output

* The resulting bytes, if any, are sent to the output instrument

=== Stop

When a connection is stopped:

* The stop bytes from the patch, if any, are sent to the output instrument
  as-is (in particular, status bytes' channels are not changed)

* The connection removes itself from its input instrument's list of outgoing
  connections

== Connection Filters

When a filter is run it is passed two arguments: the connection and an array
of MIDI bytes. Whatever the filter returns will be sent to the output
instrument.

The filter is passed the connection not only so it can read its state (for
example, the transpose value) but also so that it can modify the connection
itself. For example, a filter could change the transpose value or keyboard
zone, or even change the connection's filter itself, allowing for "hot
swapping" of filter code.

  Note that if a filter does "hot swap" itself for another filter, that
  other filter will not be saved properly when everything gets saved to a
  file.

Filter returns bytes. if bytes is nil or empty nothing sent.

= PatchMaster Files

PatchMaster files describe your MIDI setup and define triggers, songs with
their patches, and song lists. They are written in Ruby using a few special
keywords (Ruby method names).

For a sample PatchMaster file, see
examples/example.rb[https://github.com/jimm/patchmaster/blob/master/examples/example.rb].

== Editing PatchMaster Files

You can create and edit PatchMaster files using any text editor you like.

While running PatchMaster, the 'e' key lets you edit the file you loaded or
most recently saved. If you have not yet loaded a file or you save the file
to a different location, you'll have to use the 'l' load command to load
that file.

The edit command suspends PatchMaster and starts the editor defined by the
environment variables +VISUAL+ or +EDITOR+. If neither of those are defined
it tries 'vim', 'vi', and finally 'notepad.exe'.

After editing a file, PatchMaster attempts to continue with the same song
list, song, and patch that was current when you edited the file.

== Anatomy of a PatchMaster File

=== MIDI Instruments

  input/output port, symbol, optional_name

=== Triggers

  trigger input_instrument_symbol, bytes, block

Block can call PM::PatchMaster methods such as #next_patch or #prev_song.

=== Songs

  song name block

==== Patches

  patch name block

* start_bytes
* connection

==== Connections

  connection in_sym, in_chan_or_any, out_sym, out_chan, block

* prog_chg
* zone
* filter

===== Filters

=== Song Lists

== Aliases

= Miscellaneous

== Panic Button

Hitting ESCAPE sends all-notes-off messages to every output instrument on
all 16 MIDI channels. Hitting ESCAPE a second time sends individual note off
messages to every note on all 16 channels to every output instrument.

= Notes

These are development notes, not end-user notes.

* http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html
* http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf
* http://www.ruby-doc.org/stdlib-1.9.3/libdoc/curses/rdoc/index.html
* man ncurses

:include:TODO.rdoc
