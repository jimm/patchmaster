PatchMaster is realtime MIDI performance software that alloweds a musician
to totally reconfigure a MIDI setup instantaneously and modify the MIDI data
while it's being sent.

With PatchMaster a performer can split controlling keyboards, layer MIDI
channels, transpose them, send program changes and System Exclusive
messages, limit controller and velocity values, and much more. At the stomp
of a footswitch (or any other MIDI event), an entire MIDI system can be
totally reconfigured.

PatchMaster lets you describe _songs_, which are lists of _patches_ that
connect _instruments_. Those _connections_ can send program changes, set
keyboard splits, transpose, send volume or other controller changes, and let
you apply any Ruby code you want to the MIDI stream in realtime.

_Song_ _lists_ let you organize songs into "set lists" for live performance or
in the studio.

Any MIDI controller can trigger a move to the next or previous _patch_. For
example, you can tell PatchMaster to move forward or backward based on
controller values coming from foot switches or an instrument's buttons.

A software panic button turns off any stuck notes.

PatchMaster is cross-platform: it should run on MacOS X, Linux, JRuby, and
Windows.

PatchMaster is by Jim Menard (mailto:jim@jimmenard.com). It is a rewrite of
KeyMaster[http://jimmenard.com/projects/keymaster/].

= Requirements

* {UniMIDI}[https://github.com/arirusso/unimidi] gem.
* Ruby 1.9 (because UniMIDI requires it).
* Curses (comes with Ruby, but I'm not sure about JRuby)

= Installation

To install as a gem, type

  gem install patchmaster

= Running PatchMaster

  patchmaster [-n] [-d] [patchmaster_file]

Starts PatchMaster and optionally loads +patchmaster_file+.

The +-n+ flag tells PatchMaster to not use MIDI. All MIDI errors such as not
being able to connect to the MIDI instruments specified in pm_file are
ignored, and no MIDI data is sent/received. That is useful if you want to
run PatchMaster without actually talking to any MIDI instruments.

The +-d+ flag turns on debug mode. The app becomes slightly more verbose and
logs everything to +/tmp/pm_debug.txt+.

See "DSL" below for a description of the PatchMaster file format.

= Patches

Patches have connections and arrays of start and stop bytes. Each connection
links an input instrument to a single chanel on an output instrument.

When a patch is started (it becomes the _current_ _patch_), each connection
is started and passed the patch's start bytes. When a patch is stopped, each
connection is stopped and passed the stop bytes.

== Connections

Connections have an input instrument and (optional) channel, output
instrument and channel, and the following optional settings:

* Program change number (sent on the output instrument's channel)
* Keyboard zone (low/high keys stored as a Ruby Range)
* Transpose
* Filter (see "Connection Filters" below)

If the input instrument's channel is not specified then all input from that
instrument is run through the connection. If the channel is specified then
any data on other channels is ignored.

=== Start

When a connection is started:

* The start bytes from the patch, if any, are sent to the output instrument as-is

* The program change is sent

* The connection adds itslef to its input instrument's list of outgoing
  connections

=== Running

While a patch is running, incoming data on each input is sent through one or
more connections to the proper outputs. Each connection can filter and
modify the data on the way:

* The data is ignored if it is not on the input instrument's selected
  channel

* Note messages (note on, note off, and polyphonic pressure) are transposed.

* Channel messages (note on, note off, polyphonic pressure, controller,
  program change, channel pressure, and pitch bend) have their channel
  changed to the output instrument's selected channel

* The filter code, if any, is run and the result of that block becomes the
  output data

* The resulting data, if any, is sent to the output instrument

=== Stop

When a connection is stopped:

* The stop bytes from the patch, if any, are sent to the output instrument
  as-is

* The connection removes itself from its input instrument's list of outgoing
  connections

== Connection Filters

When a filter is run it is passed two arguments: the connection and an array
of MIDI bytes. Whatever the filter returns will be sent to the output
instrument.

The filter is passed the connection not only so it can read its state (for
example, the transpose value) but also so that it can modify the connection
itself. For example, a filter could change the transpose value or keyboard
zone, or even change the connection's filter itself, allowing for "hot
swapping" of filter code.

  Note that if a filter does "hot swap" itself for another filter, that
  other filter will not be saved properly when everything gets saved to a
  file.

Filter returns bytes. if bytes is nil or empty nothing sent.

= DSL

TODO write this. In the mean time, see link:../examples/example.rb .

= Notes

* http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html
* http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf
* http://www.ruby-doc.org/stdlib-1.9.3/libdoc/curses/rdoc/index.html
* man ncurses

:include:TODO.rdoc
