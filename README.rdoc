= PatchMaster

PatchMaster is real time MIDI performance software that allows a musician to
totally reconfigure a MIDI setup instantaneously and modify the MIDI data
while it's being sent.

With PatchMaster a performer can split controlling keyboards, layer MIDI
channels, transpose them, send program changes and System Exclusive
messages, limit controller and velocity values, and much more. At the stomp
of a foot switch (or any other MIDI event), an entire MIDI system can be
totally reconfigured.

PatchMaster lets you describe _songs_, which are lists of _patches_ that
connect _instruments_. Those _connections_ can send program changes, set
keyboard splits, transpose, send volume or other controller changes, and let
you apply any Ruby code you want to the MIDI stream in real time.

_Song_ _lists_ let you organize songs into set lists for live performance or
in the studio.

Any MIDI message can _trigger_ an action such as moving to the next or
previous patch or song. For example, you can tell PatchMaster to move
forward or backward based on controller values coming from foot switches or
an instrument's buttons.

Any array of MIDI bytes can be stored as a named _message_ which can be sent
via a trigger, a key press, or from any filter.

A software panic button turns off any stuck notes.

PatchMaster is cross-platform: it should run on Mac OS X, Linux, JRuby, and
Windows.

PatchMaster is by Jim Menard (mailto:jim@jimmenard.com). It is a rewrite of
KeyMaster[http://jimmenard.com/projects/keymaster/].

= Requirements

* {midi-eye}[https://github.com/arirusso/midi-eye] gem, which will be
  installed automatically if you install PatchMaster as a gem. midi-eye in
  turn requires (and will install automatically):
  * {midi-message}[https://github.com/arirusso/midi-message]
  * {nibbler}[https://github.com/arirusso/nibbler]
  * {unimidi}[https://github.com/arirusso/unimidi]
* Ruby 1.9 (because UniMIDI requires it)
* Curses (comes with Ruby, but I'm not sure about JRuby)

= Installation

To install as a gem, type

  gem install patchmaster

= Running PatchMaster

  patchmaster [-n] [-t] [-d] [patchmaster_file]

Starts PatchMaster and optionally loads +patchmaster_file+.

The +-n+ flag tells PatchMaster to not use MIDI. All MIDI errors such as not
being able to connect to the MIDI instruments specified in pm_file are
ignored, and no MIDI data is sent/received. That is useful if you want to
run PatchMaster without actually talking to any MIDI instruments.

The +-t+ flag runs the app without Curses windows. All output will go to the
console. The app will run until interrupted. (If you do this, you might want
to create a trigger that calls +panic+, because you won't be able to use the
computer keyboard to do that.)

The +-d+ flag turns on debug mode. The app becomes slightly more verbose and
logs everything to +/tmp/pm_debug.txt+.

See "Anatomy of a PatchMaster File" below for a description of the
PatchMaster file format.

= Patches

Each patch contains connections and an array of start and stop bytes. Each
connection links an input instrument to a single channel on an output
instrument.

When a patch is started (it becomes the _current_ _patch_), each connection
is started and passed the patch's start bytes to send to its output
instrument. When a patch is stopped, each connection is stopped and passed
the stop bytes to send to its output.

== Connections

Connections have an input instrument and (optional) channel, output
instrument and channel, and the following optional settings:

* Program change number (sent on the output instrument's channel)
* Keyboard zone (low/high keys stored as a Ruby Range)
* Transpose
* Filter (see "Connection Filters" below)

If the input instrument's channel is not specified then all input from that
instrument is run through the connection. If the channel is specified then
any data on other channels is ignored.

=== Start

When a connection is started:

* The start bytes from the patch, if any, are sent to the output instrument
  as-is (in particular, status bytes' channels are not changed)

* The program change is sent

* The connection adds itself to its input instrument's list of outgoing
  connections

=== Running

When MIDI data comes in from an instrument two things happen:

* The data is sent to the instrument's triggers. Each trigger looks at the
  data and decides if it should act by send its message (for example
  +next_patch+ or +next_song+) to PM::PatchMaster.

* The data is then sent to the connections connected to the instrument, if
  any. A patch's connections are connected to an input instrument when the
  patch starts (becomes the active patch) and are disconnected when the
  patch stops.

While a patch is running (it is the current patch), each connection is given
the incoming bytes to process. A connection can filter and modify the data
on the way:

* The data is ignored if it is not on the input instrument's selected
  channel

* Note messages (note on, note off, and polyphonic pressure) are transposed

* Channel messages (note on, note off, polyphonic pressure, controller,
  program change, channel pressure, and pitch bend) have their channel
  changed to the output instrument's selected channel

* If the connection has a filter, its block of code is run and the result of
  that block becomes the bytes to be output. The filter may return an empty
  array or nil which will prevent anything from being sent to the output

* The resulting bytes, if any, are sent to the output instrument

=== Stop

When a connection is stopped:

* The stop bytes from the patch, if any, are sent to the output instrument
  as-is (in particular, status bytes' channels are not changed)

* The connection removes itself from its input instrument's list of outgoing
  connections

== Connection Filters

When a filter is run it is passed two arguments: the connection and an array
of MIDI bytes. Whatever the filter returns will be sent to the output
instrument.

The filter is passed the connection not only so it can read its state (for
example, the transpose value) but also so that it can modify the connection
itself. For example, a filter could change the transpose value or keyboard
zone, or even change the connection's filter itself, allowing for "hot
swapping" of filter code.

  Note that if a filter does "hot swap" itself for another filter, that
  other filter will not be saved properly when everything gets saved to a
  file.

Filter returns bytes. if bytes is nil or empty nothing sent.

= PatchMaster Files

PatchMaster files describe your MIDI setup and define triggers, songs with
their patches, and song lists. They are written in Ruby using a few special
keywords (Ruby method names).

For a sample PatchMaster file, see
examples/example.rb[https://github.com/jimm/patchmaster/blob/master/examples/example.rb].

== Editing PatchMaster Files

You can create and edit PatchMaster files using any text editor you like.

While running PatchMaster, the 'e' key lets you edit the file you loaded or
most recently saved. If you have not yet loaded a file or you save the file
to a different location, PatchMaster will ask you for a file name.

The edit command suspends PatchMaster and starts the editor defined by the
environment variables +VISUAL+ or +EDITOR+. If neither of those are defined
it tries 'vim', 'vi', and finally 'notepad.exe'.

After editing a file, PatchMaster attempts to continue with the same song
list, song, and patch that was current when you edited the file.

When you edit a file from within PatchMaster, it has no way of knowing if
you saved that file to a different location. If you do so and want to load
that file you'll have to use the 'l' command to do so.

== Anatomy of a PatchMaster File

=== MIDI Instruments

  input/output port, symbol, optional_name

Describes MIDI inputs and outputs.

Symbols must be unique within instrument type (input or output). For
example, you can have an input instrument with the symbol :ws and an output
instrument with the same symbol :ws, but you can't have two inputs or two
outputs with the same symbol.

Example:

  input  0, :mb, 'midiboard'
  input  1, :ws_in, 'WaveStation'
  output 1, :ws_out, 'WaveStation'
  output 2, :kz, 'K2000R'
  output 4, :sj                   # Name will come from UNIMidi

=== Messages

  message name, bytes

Stores a named MIDI message. These messages can be sent at any time using
message keys or triggers, and can be sent from filters.

Message names, when referenced by message keys, triggers, or filters, are case
sensitive.

Messages sent from filters are sent before the filtered bytes are sent. Make
sure the filter returns the filtered bytes after sending your message. If
you send the mesasge last in your filter then no other bytes will be sent.

  # WRONG
  filter do |conn, bytes|
    send_message "Interesting Bytes"
  end

  # RIGHT
  filter do |conn, bytes|
    send_message "Interesting Bytes"
    bytes     # pass through original bytes unchanged
  end

=== Message Keys

  message_key name, key

Maps the named message to a key. Message keys are ignored if PatchMaster was
started without Curses. +key+ may be any one-character string (for example
'8' or 'p') or a function key symbol of the form +:f1+, +:f2+, etc.

=== Triggers

  trigger input_instrument_symbol, bytes, block

Input MIDI messages can trigger behaviors. When +bytes+ are sent from the
given input instrument then +block+ is executed. All of the methods of
PM::PatchMaster are made available to the trigger, so for example the block
can call methods such as #next_patch, #prev_song, or #send_message.

Example:

  trigger :mb, [CONTROLLER, CC_GEN_PURPOSE_5, 0] { next_patch }
  trigger :mb, [CONTROLLER, CC_GEN_PURPOSE_6, 0] { prev_patch }
  trigger :mb, [CONTROLLER, 126, 127] { send_message "Tune Request" }

=== Songs

  song name block

A song is an list of patches.

Example:

  song "My First Song" do
    # ...
  end

==== Patches

  patch name block

A patch contains connections and optional start and stop byte arrays.

* start_bytes
* stop_bytes
* connection

Example:

  song "My First Song" do
    patch "First Song, First Patch" do
      start_bytes [TUNE_REQUEST]
      connection :mb, nil, :kz, 2 do  # all chans from :mb, out to ch 2 on :kz
        # ...
      end
      connection :ws, 6, :sj, 4 do  # only ch 6 from :ws_kbd, out to ch 4 on :sj
        # ...
      end
      conn :ws, 6, :d4, 10
    end
  end

==== Connections

  connection in_sym, in_chan_or_any, out_sym, out_chan, block

Connects input to output. A connection can optionally specify a program
change number (sent to the output instrument on +out_chan+), a zone, and a
filter (see below).

* prog_chg
* zone
* filter

Example:

  song "My First Song" do
    patch "First Song, First Patch" do
      connection :ws, 6, :sj, 4 do  # only chan 6 from :ws, out to ch 4 on :sj
        prog_chg 100
        zone C4, B5
        filter { |connection, bytes|
          # ...
        }
      end
    end
  end

===== Filters

  filter block_with_two_args

Filters are applied as the last step in a connection's modification of the
MIDI data. This means that the status byte's channel is already changed to
the output instrument's channel for this connection (assuming the message is
a channel message).

Example:

  song "My First Song" do
    patch "First Song, First Patch" do
      connection :ws, 6, :sj, 4 do  # only chan 6 from :ws, out to ch 4 on :sj
        prog_chg 100
        zone C4, B5
        filter { |connection, bytes|
          if bytes.note_off?
            bytes[2] -= 1 unless bytes[2] == 0 # decrease velocity by 1
          end
        }
      end
    end
  end

=== Song Lists

  song_list name, [song_name, song_name...]

Optional.

Example:

  song_list "Tonight's Song List", [
    "First Song",
    "Second Song"
  ]

== Aliases

Many of the keywords have short versions.

input :: in
output :: out
connection :: conn, c
prog_chg :: pc
zone :: z
transpose :: xpose, x
filter :: f

= Tips and Tricks

== Don't Panic!

Hitting ESCAPE sends all-notes-off messages to every output instrument on
all 16 MIDI channels. Hitting ESCAPE a second time sends individual note off
messages to every note on all 16 channels to every output instrument.

== What?

predicates.rb defines methods on Integer and Array that might be useful to
you when writing filters or triggers. Most of the Array methods apply
themselves to the first byte, so for example these two are equivalent:

  my_array.controller?
  my_array[0].controller?

== From One, Many

You can turn one note into multiple notes either by setting up two different
connections that connect the same input to the same output, or by writing a
filter that turns one message into multiple like this:

  filter { |conn, bytes|
    if bytes.note?
      bytes += bytes    # duplicate note message
      byte.last += 12   # add octave to second note's value
  }

This also shows the use of the predicate method #note? which returns true
for note on, note off, and poly pressure messages.

== This One Goes to 11

Use start bytes to set initial volumes for instruments.

== Hands-Free

Use PatchMaster to play notes! A patch's start bytes can be used to play one
or more notes-on messages, and the stop bytes can be used to play the
corresponding note-off messages.

== And Now, a Massage from the Swedish Prime Minister

You don't have to enter message byte arrays manually. You can build up the
message using Ruby code, storing it in a variable, and then hand that
variable to the +message+ method. See examples/example.rb.

Messages can be sent not only from the keyboard but also from a trigger or a
filter by calling

  send_message "Message Name"

== Method to Your Madness

You can write your own methods in the PatchMaster file and call them from
triggers and filters. Your method has access to the PM::PatchMaster methods
and instance variables --- for example, @outputs is the array of all output
instruments.

  def output_silly_bytes
    @outputs.each { |out| out.midi_out([1, 2, 3] } # Don't really send that
  end
    
  trigger :mb, [CONTROLLER, 126, 127] { output_silly_bytes }

== Tuning

You might want to set up a song that helps you tune your instruments
by sending the proper program changes and entering note on and note
off commands that play the tuning note on different synths. (<i>Yes,
you actually had to tune most older synths.</i>) For example,

1. Patch One

   * Start message: program changes and note-ons for reference synth A and
     another synth (B).
   * Stop message: note-off for synth B.

2. Patch Two

   * Start message: program change and note-on for synth C.
   * Stop message: note-off for synth C.

3. Patch Three

   * Start message: program change and note-on for synth D.
   * Stop message: note-offs for synth D and reference synth A.

:include:CHANGES.rdoc

:include:TODO.rdoc
